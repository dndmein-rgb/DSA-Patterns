/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ—“ï¸ Pattern: Sliding Window (Variable Size + Frequency Requirement)
ðŸ”¢ Problem: 76. Minimum Window Substring
ðŸ“… Date: January 8, 2026
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŽ¯ Problem: 76. Minimum Window Substring
ðŸ“Œ Link: https://leetcode.com/problems/minimum-window-substring/
ðŸ·ï¸ Difficulty: Hard
ðŸ† Topics: Hash Table, String, Sliding Window

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- Two strings `s` and `t` of lengths `m` and `n` respectively.

Goal:
- Return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If no such substring exists, return "".

Key Insight:
- This is the ultimate **Variable Size Sliding Window** challenge. 
- We expand the window until it is "desirable" (contains all characters of `t`).
- Once desirable, we contract from the left as much as possible to find the **minimum** window while still maintaining the "desirable" property.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ’¡ Approach (Expand and Contract Strategy)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Frequency Maps**:
   - `need`: Stores frequency of characters in `t`.
   - `window`: Stores frequency of characters in the current window of `s`.
2. **State Tracking**:
   - `required`: Number of unique characters in `t` that must be present in the window.
   - `formed`: Number of unique characters currently in the window that meet the required frequency count.
3. **The Two-Step Slide**:
   - **Step 1 (Expand)**: Move `j` to the right. If `window[s[j]]` matches `need[s[j]]`, increment `formed`.
   - **Step 2 (Contract)**: While `formed == required`, update the `minLen` and `start` index. Then, move `i` to the right, decrementing counts. If a character's count drops below what's `need`ed, decrement `formed`.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    string minWindow(string s, string t) {
        if (t.size() > s.size()) return "";

        // need[256] stores frequency of chars in t
        // window[256] stores frequency of chars in current window
        vector<int> need(256, 0), window(256, 0);
        int required = 0;
        
        for (char c : t) {
            if (need[c] == 0) required++;
            need[c]++;
        }

        int minLen = 1e9;
        int formed = 0; // tracks how many unique characters meet the count in 'need'
        int i = 0, j = 0, start = 0;

        while (j < s.size()) {
            char c = s[j];
            window[c]++;

            // If the current character's frequency matches the required frequency in t
            if (need[c] > 0 && window[c] == need[c]) {
                formed++;
            }

            // Try and contract the window till the point where it ceases to be 'desirable'
            while (i <= j && formed == required) {
                // Update minimum length found so far
                if (j - i + 1 < minLen) {
                    minLen = j - i + 1;
                    start = i;
                }

                char leftChar = s[i];
                window[leftChar]--;

                // If removing the left character breaks the requirement for that character
                if (need[leftChar] > 0 && window[leftChar] < need[leftChar]) {
                    formed--;
                }
                i++;
            }
            j++;
        }

        return minLen == 1e9 ? "" : s.substr(start, minLen);
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(M + N)
   â””â”€ M is length of s, N is length of t. We process each string at most twice.
   
ðŸ’¾ Space Complexity: O(K)
   â””â”€ K is the character set size (256). Since K is constant, it's effectively O(1).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ” Example Walkthrough (s = "ADOBECODEBANC", t = "ABC")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Expand j until "ADOBEC". Window contains A, B, C. formed == required.
2. Contract i: "ADOBEC" -> "DOBEC" (no A). formed < required.
3. Expand j until "DOBECOBANC".
4. Contract i: finds "BANC", then "ANC", eventually finds "BANC" is the best.
Result: "BANC".
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
