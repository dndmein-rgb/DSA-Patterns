/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Pattern: Sliding Window (Fixed Size + Frequency Hashing)
ğŸ”¢ Problem: 567. Permutation in String
ğŸ“… Date: January 8, 2026
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 567. Permutation in String
ğŸ“Œ Link: https://leetcode.com/problems/permutation-in-string/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Hash Table, Two Pointers, String, Sliding Window

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- Two strings `s1` and `s2`.

Goal:
- Return `true` if `s2` contains a permutation of `s1`, or `false` otherwise.
- In other words, check if any substring of `s2` is an anagram of `s1`.

Key Insight:
- A permutation of a string means the character counts must be identical.
- Since the permutation must be a **substring** of `s2`, the window size in `s2` is **fixed** to the length of `s1`.
- This is a **Fixed-Size Sliding Window** problem where we compare frequency arrays.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach (Fixed Window Frequency Matching)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Frequency Mapping**: Create a frequency array `need` for `s1`.
2. **Fixed Window**: 
   - Maintain a `window` frequency array for `s2`.
   - The size of the window should never exceed `n = s1.length()`.
3. **Slide and Compare**:
   - Expand the window by adding `s2[j]`.
   - If the window size exceeds `n`, shrink it from the left by removing `s2[i]`.
   - At each step where the window size is exactly `n`, compare `need` and `window`. If they match, a permutation is found.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n = s1.length();
        int m = s2.length();
        
        // If s1 is longer than s2, s2 cannot contain a permutation of s1
        if (n > m) return false;

        // Frequency arrays for characters 'a'-'z'
        vector<int> need(26, 0), window(26, 0);
        
        // Populate the requirements from s1
        for (char c : s1) {
            need[c - 'a']++;
        }

        int i = 0; // Left pointer
        int j = 0; // Right pointer
        
        while (j < m) {
            // Add current character to window
            window[s2[j] - 'a']++;
            
            // If window size exceeds the length of s1, slide the left boundary
            if (j - i + 1 > n) {
                window[s2[i] - 'a']--;
                i++;
            }
            
            // Compare the two frequency maps
            // In C++, vector equality '==' is O(26) which is effectively O(1)
            if (need == window) return true;
            
            j++;
        }
        
        return false;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(M)
   â””â”€ We traverse string s2 once. The vector comparison (need == window) takes O(26) time.
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ We use two fixed-size vectors of size 26 regardless of input string lengths.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough (s1 = "ab", s2 = "eidbaooo")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. need = {a:1, b:1}. n = 2.
2. j=0,1: window = {e:1, i:1}. Size=2. Not a match.
3. j=2: window adds 'd', removes 'e'. window = {i:1, d:1}. Not a match.
4. j=3: window adds 'b', removes 'i'. window = {d:1, b:1}. Not a match.
5. j=4: window adds 'a', removes 'd'. window = {b:1, a:1}.
6. window == need? TRUE.
Result: true.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
